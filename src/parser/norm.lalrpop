use std::borrow;

use ast;
use parser;

use std::str::FromStr;

grammar;

pub Norm: ast::Norm<'input> = {
    Definition* => ast::Norm { definitions: <>.into_iter().collect() },
}

pub Comment: () = {
    r"/\*.*\*/"=> ()
}

pub Definition: (ast::Identifier<'input>, ast::Expression<'input>) = {
    Comment? <Identifier> "=" <Expression> ";" => (<>),
}

pub Expression: ast::Expression<'input> = {
    Identifier => ast::Expression::Identifier(<>),
    Number => ast::Expression::Number(<>),
    String => ast::Expression::String(<>),
    Tuple => ast::Expression::Tuple(<>),
    Record => ast::Expression::Record(<>),
    Lambda => ast::Expression::Lambda(<>),
    Select => ast::Expression::Select(<>),
    Apply => ast::Expression::Apply(<>),
}

pub Identifier: ast::Identifier<'input> = {
    r"\p{XID_Start}\p{XID_Continue}*" => ast::Identifier(<>.into()),
}

#[inline]
Comma<A>: Vec<A> = {
    <v:(<A> ",")*> <e: A?> => {
        let mut v = v;
        v.extend(e);
        v
    },
}

#[inline]
Semi<A>: Vec<A> = {
    <v:(<A> ";")*> <e: A> => {
        let mut v = v;
        v.push(e);
        v
    },
}

pub Tuple: ast::Tuple<'input> = {
    "(" <Comma<Expression>> ")" => ast::Tuple { fields: <> },
}

pub Record: ast::Record<'input> = {
    "{" <Comma<Field>> "}" => ast::Record { fields: <>.into_iter().collect() },
}

pub Field: (ast::Identifier<'input>, ast::Expression<'input>) = {
     <Identifier> ":" <Expression> => (<>)
}

pub Number: f64 = {
    r"-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?" => f64::from_str(<>).unwrap(),
}

pub String: borrow::Cow<'input, str> = {
    r#""(?:[^"\\]|\\(?:["\\/bfnrt]|u\{[a-fA-F0-9]{1,6}\}))*""# => parser::parse_escaped_string(<>),
}

pub Lambda: ast::Lambda<'input> = {
    "|" <parameters:Comma<Parameter>> "|" "{" <statements:Semi<Statement>> "}" => ast::Lambda { <> },
}

pub Statement: ast::Statement<'input> = {
    <d:Definition> => ast::Statement::Definition(d.0, d.1),
    Comment? <Expression> => ast::Statement::Expression(<>),
}

pub Select: ast::Select<'input> = {
    <e:Expression> "." <f:Identifier> => ast::Select { expression: Box::new(e), field: f },
}

pub Apply: ast::Apply<'input> = {
    <e:Expression> "(" <p:Comma<Expression>> ")" => ast::Apply { function: Box::new(e), parameters: p },
}

pub Parameter: ast::Parameter<'input> = {
    <name:Identifier> <signature:(":" <Expression>)?> => ast::Parameter { <> },
}
